
import java.util.*;
import java.lang.*;
import java.io.*;

class Box {

    public static final float UNIVERSAL_EPSILON_VAL = 0.0000001f;

    boolean isPerfectBox;
    float width;
    float height;
    float boxAngle;
    Coordinates SW;
    Coordinates SE;
    Coordinates NW;
    Coordinates NE;
    Coordinates centerPoint;

    public Box(float boxHeight, float boxWidth, float angle, Coordinates centerPnt) {
        height = boxHeight;
        width = boxWidth;
        centerPoint = centerPnt;

        if (angle > 360.0f) {
            boxAngle = Box.convertOverflowingAngle(angle);
        } else if (angle < 0.0f) {
            boxAngle = Box.convertNegativeAngle(angle);
        } else {
            boxAngle = angle;
        }

        //Angle is correct here
        float radialAngle = (float) (Math.atan((0.5f * width) / (0.5f * height)) * (180.0f / Math.PI));
        float radialAnglePos = Box.convertOverflowingAngle(boxAngle + radialAngle);
        float radialAngleNegative = Box.convertNegativeAngle(boxAngle - radialAngle);
        float radialDist = (0.5f * width) / (float) (Math.sin(Math.toRadians(radialAngle)));

        Coordinates genericPointOne = Box.getEndPointOfLine(radialDist, radialAnglePos, centerPoint);
        Coordinates genericPointTwo = Box.getEndPointOfLine(radialDist, Box.convertOverflowingAngle(radialAnglePos + 180), centerPoint);
        Coordinates genericPointThree = Box.getEndPointOfLine(radialDist, radialAngleNegative, centerPoint);
        Coordinates genericPointFour = Box.getEndPointOfLine(radialDist, Box.convertNegativeAngle(radialAngleNegative - 180), centerPoint);

        if ((boxAngle > 0 && boxAngle < 90) || (boxAngle > 270 && boxAngle < 360)) {
            NW = genericPointFour;
            SW = genericPointTwo;
            NE = genericPointOne;
            SE = genericPointThree;
        } else if (((boxAngle > 90) && (boxAngle != 180) && (boxAngle < 270))) {
            NW = genericPointThree;
            SW = genericPointOne;
            NE = genericPointTwo;
            SE = genericPointFour;
        } else {
            isPerfectBox = true;
            if ((Math.abs(boxAngle - 0) < UNIVERSAL_EPSILON_VAL)
                    || (Math.abs(boxAngle - 180) < UNIVERSAL_EPSILON_VAL)
                    || (Math.abs(boxAngle - 360) < UNIVERSAL_EPSILON_VAL)) {
                NW = new Coordinates(centerPoint.getX() - 0.5f * height, centerPoint.getY() + 0.5f * width);
                SW = new Coordinates(centerPoint.getX() - 0.5f * height, centerPoint.getY() - 0.5f * width);
                NE = new Coordinates(centerPoint.getX() + 0.5f * height, centerPoint.getY() + 0.5f * width);
                SE = new Coordinates(centerPoint.getX() + 0.5f * height, centerPoint.getY() - 0.5f * width);
            } else if ((Math.abs(boxAngle - 90) < UNIVERSAL_EPSILON_VAL)
                    || (Math.abs(boxAngle - 270) < UNIVERSAL_EPSILON_VAL)) {
                NW = new Coordinates(centerPoint.getX() - 0.5f * width, centerPoint.getY() + 0.5f * height);
                SW = new Coordinates(centerPoint.getX() - 0.5f * width, centerPoint.getY() - 0.5f * height);
                NE = new Coordinates(centerPoint.getX() + 0.5f * width, centerPoint.getY() + 0.5f * height);
                SE = new Coordinates(centerPoint.getX() + 0.5f * width, centerPoint.getY() - 0.5f * height);
            } else {
                System.out.println("No angle found. Inside Box class constructor");
            }
        }

    }

    public Box(Coordinates NWpoint, Coordinates SWpoint, Coordinates NEpoint, Coordinates SEpoint) {

        if (!(Math.abs(NWpoint.getX() - SWpoint.getX()) < UNIVERSAL_EPSILON_VAL)
                || !(Math.abs(NEpoint.getX() - SEpoint.getX()) < UNIVERSAL_EPSILON_VAL)
                || !(Math.abs(NWpoint.getY() - NEpoint.getY()) < UNIVERSAL_EPSILON_VAL)
                || !(Math.abs(SWpoint.getY() - SEpoint.getY()) < UNIVERSAL_EPSILON_VAL)) {
            System.out.println("perf box const given corners that ar enot perfect/accurate");
            return;
        }

        isPerfectBox = true;
        NW = NWpoint;
        SW = SWpoint;
        NE = NEpoint;
        SE = SEpoint;

    }

    public static Coordinates getEndPointOfLine(float lineLength, float lineAngle, Coordinates startPoint) {
        if (lineAngle > 360) {
            lineAngle = Box.convertOverflowingAngle(lineAngle);
        }
        if (lineAngle < 0) {
            lineAngle = Box.convertNegativeAngle(lineAngle);
        }

        int angleQuadrant = (int) Math.abs((lineAngle - (lineAngle % 90)) / 90);
        float xOffset = (float) Math.abs(Math.cos(lineAngle * (Math.PI / 180)) * lineLength);
        float yOffset = (float) Math.abs(Math.sin(lineAngle * (Math.PI / 180)) * lineLength);

        int angleMultX = 100000;
        int angleMultY = 100000;
        Coordinates endPoint = new Coordinates();
        if (angleQuadrant == 0) {
            angleMultX = 1;
            angleMultY = 1;
        } else if (angleQuadrant == 1) {
            angleMultX = -1;
            angleMultY = 1;
        } else if (angleQuadrant == 2) {
            angleMultX = -1;
            angleMultY = -1;
        } else if (angleQuadrant == 3) {
            angleMultX = 1;
            angleMultY = -1;
        }

        endPoint.setCoordinates(startPoint.getX() + xOffset * angleMultX, startPoint.getY() + yOffset * angleMultY);
        return endPoint;
    }

    public boolean pointIsInPerfectBox(Coordinates testPoint) {
        if (!isPerfectBox) {
            System.out.println("perfect box test isn't perfect, try again");
            return false;
        }

        if (testPoint.getX() > this.getNW().getX()
                && testPoint.getX() < this.getNE().getX()
                && testPoint.getY() > this.getNW().getY()
                && testPoint.getY() > this.getSW().getY()) {
            return true;
        } else {
            return false;
        }
    }

    public boolean anyPointsAreInPerfectBox(Coordinates[] testPoints) {
        if (!isPerfectBox) {
            System.out.println("perfect box test isn't perfect, try again");
            return false;
        }

        for (int i = 0; i < testPoints.length; i++) {
            if (testPoints[i].getX() > NW.getX()
                    && testPoints[i].getX() < NE.getX()
                    && testPoints[i].getY() < NW.getY()
                    && testPoints[i].getY() > SW.getY()) {
                return true;
            }
        }

        return false;
    }

    public static boolean anyPointsAreInPerfectBox(Coordinates[] testPoints, Coordinates cornerPointOne, Coordinates cornerPointTwo) {
        float greatestX;
        float greatestY;
        float leastX;
        float leastY;
        if (cornerPointOne.getX() > cornerPointTwo.getX()) {
            greatestX = cornerPointOne.getX();
            leastX = cornerPointTwo.getX();
        } else {
            greatestX = cornerPointTwo.getX();
            leastX = cornerPointOne.getX();
        }

        if (cornerPointOne.getY() > cornerPointTwo.getY()) {
            greatestY = cornerPointOne.getY();
            leastY = cornerPointTwo.getY();
        } else {
            greatestY = cornerPointTwo.getY();
            leastY = cornerPointOne.getY();
        }

        for (int i = 0; i < testPoints.length; i++) {
            if (testPoints[i].getX() >= leastX
                    && testPoints[i].getX() <= greatestX
                    && testPoints[i].getY() >= leastY
                    && testPoints[i].getY() <= greatestY) {
                //System.out.println("test: true");
                return true;
            }
        }
        //System.out.println("test: false");
        return false;
    }

    public static boolean anyPointsAreInRightTriangle(Coordinates startPoint, Coordinates ninetyDegreePoint, Coordinates endPoint, Coordinates[] testPoints) {
        /*
         if(
         !(Math.abs(startPoint.getX()-ninetyDegreePoint.getX()) < UNIVERSAL_EPSILON_VAL && Math.abs(endPoint.getY()-ninetyDegreePoint.getY()) < UNIVERSAL_EPSILON_VAL) ||
         !(Math.abs(endPoint.getX()-ninetyDegreePoint.getX())  < UNIVERSAL_EPSILON_VAL && Math.abs(startPoint.getY()-ninetyDegreePoint.getY()) < UNIVERSAL_EPSILON_VAL)
         ){
         System.out.println("nienteyDegreePoint isn;t at 90 deg, returning");
         return false;
         }
         */

        //System.out.println(startPoint.getX()+", "+startPoint.getY());
        //System.out.println(ninetyDegreePoint.getX()+", "+ninetyDegreePoint.getY());
        //System.out.println(endPoint.getX()+", "+endPoint.getY());
        int angleMultX = startPoint.getX() > endPoint.getX() ? -1 : 1;
        int angleMultY = startPoint.getY() > endPoint.getY() ? -1 : 1;

        //System.out.println(angleMultX);
        //System.out.println(angleMultY);
        int innerMultX = 0;
        int innerMultY = 0;
        if (Math.abs(startPoint.getX() - ninetyDegreePoint.getX()) < UNIVERSAL_EPSILON_VAL
                && Math.abs(endPoint.getY() - ninetyDegreePoint.getY()) < UNIVERSAL_EPSILON_VAL) {
            if (angleMultX == 1 && angleMultY == 1) {
                innerMultX = -1;
                innerMultY = 1;
            } else if (angleMultX == 1 && angleMultY == -1) {
                innerMultX = -1;
                innerMultY = -1;
            } else if (angleMultX == -1 && angleMultY == -1) {
                innerMultX = 1;
                innerMultY = -1;
            } else {
                innerMultX = -1;
                innerMultY = -1;
            }
        } else if (Math.abs(startPoint.getY() - ninetyDegreePoint.getY()) < UNIVERSAL_EPSILON_VAL
                && Math.abs(endPoint.getX() - ninetyDegreePoint.getX()) < UNIVERSAL_EPSILON_VAL) {
            if (angleMultX == 1 && angleMultY == 1) {
                innerMultX = 1;
                innerMultY = -1;
            } else if (angleMultX == 1 && angleMultY == -1) {
                innerMultX = 1;
                innerMultY = 1;
            } else if (angleMultX == -1 && angleMultY == -1) {
                innerMultX = -1;
                innerMultY = 1;
            } else {
                innerMultX = 1;
                innerMultY = 1;
            }
        } else {
            System.out.println("No multipliers set; inside anyPointsAreInsideRightTriangle");
        }

        float xDist = Math.abs(startPoint.getX() - endPoint.getX());
        float yDist = Math.abs(startPoint.getY() - endPoint.getY());
        float currentMult = 1;

        int currentBoxNum;
        float currentXDist;
        float currentYDist;
        Coordinates currentHypotenusePoint = new Coordinates();
        Coordinates currentInnerPoint = new Coordinates();

        for (int i = 1; i < 5; i++) {
            currentMult /= 2;
            currentBoxNum = (int) (1.0f / (currentMult * 2));
            currentXDist = xDist * currentMult;
            currentYDist = yDist * currentMult;
            currentHypotenusePoint.setCoordinates(startPoint.getX() + currentXDist * angleMultX, startPoint.getY() + currentYDist * angleMultY);
            currentInnerPoint.setCoordinates(currentHypotenusePoint.getX() + currentXDist * innerMultX, currentHypotenusePoint.getY() + currentYDist * innerMultY);

            //Box.printCoordinates(currentHypotenusePoint);
            //Box.printCoordinates(currentInnerPoint);
            for (int j = 0; j < currentBoxNum; j++) {
                if (Box.anyPointsAreInPerfectBox(testPoints, currentHypotenusePoint, currentInnerPoint)) {
                    System.out.println("PENISISOLFLKSDJFSD");
                    return true;
                }
                currentHypotenusePoint.setCoordinates(currentHypotenusePoint.getX() + 2 * currentXDist * angleMultX, currentHypotenusePoint.getY() + 2 * currentYDist * angleMultY);
                currentInnerPoint.setCoordinates(currentHypotenusePoint.getX() + currentXDist * innerMultX, currentHypotenusePoint.getY() + currentYDist * innerMultY);
                //System.out.println(currentHypotenusePoint.getX() + ", " + currentHypotenusePoint.getY());
                //System.out.println(currentInnerPoint.getX() + ", " + currentInnerPoint.getY());
            }
        }

        for (Coordinates c : testPoints) {
            if ((Math.abs(c.getX() - startPoint.getX()) < UNIVERSAL_EPSILON_VAL && Math.abs(c.getY() - startPoint.getY()) < UNIVERSAL_EPSILON_VAL)
                    || (Math.abs(c.getX() - endPoint.getX()) < UNIVERSAL_EPSILON_VAL && Math.abs(c.getY() - endPoint.getY()) < UNIVERSAL_EPSILON_VAL)) {
                return true;
            }
        }

        return false;
    }

    public static float getDistanceBetween(Coordinates startPoint, Coordinates endPoint) {
        //d = squareRootOf( (x2-x1)^2 + (y2-y1)^2 )
        float dist = (float) Math.sqrt(Box.squareFloat(Math.abs(endPoint.getX() - startPoint.getX())) + Box.squareFloat(Math.abs(endPoint.getY() - startPoint.getY())));
        return dist;
    }

    public static void translateBoxXWise(float xDist) {
        //Check to see if any of the new coords will be negative and move the box closest as it will get to that neg (0) if it is, also
        //throw up an error or printed message about it
        //Transfer all x's of the corners and center point by +/- the x value given
    }

    public void translateBoxYWise(float yDist) {

    }

    public void translateBoxXAndYWise(float xDist, float yDist) {

    }

    public void rotateBoxByDeg(float degrees) {

    }

    public void printCorners() {
        System.out.println("NW: (" + NW.getX() + ", " + NW.getY() + ")");
        System.out.println("SW: (" + SW.getX() + ", " + SW.getY() + ")");
        System.out.println("NE: (" + NE.getX() + ", " + NE.getY() + ")");
        System.out.println("SE: (" + SE.getX() + ", " + SE.getY() + ")");
    }

    public void printCornersForTesting() {
        System.out.println(NW.getX() + "," + NW.getY());
        System.out.println(SW.getX() + "," + SW.getY());
        System.out.println(NE.getX() + "," + NE.getY());
        System.out.println(SE.getX() + "," + SE.getY());
    }

    public static void printCoordinates(Coordinates c) {
        if (c == null) {
            //System.out.println("Point is null.");
        } else {
            System.out.println(c.getX() + ", " + c.getY());
        }
    }

    public static void printCoordinates(Coordinates[] cArr) {
        for (Coordinates c : cArr) {
            System.out.println(c.getX() + ", " + c.getY());
        }
    }

    public static float squareFloat(float num) {
        return num * num;
    }

    public static float convertOverflowingAngle(float angle) {
        if (angle > 360.0f) {
            angle = angle % 360.0f;
            return angle;
        } else {
            return angle;
        }
    }

    public static float convertNegativeAngle(float angle) {
        if (Math.abs(angle) * 1 != angle) {
            if (Math.abs(angle) > 360) {
                System.out.println(angle);
                angle = Box.convertOverflowingAngle(Math.abs(angle));
            }
            angle = 360 - Math.abs(angle);
            return angle;
        } else {
            return angle;
        }
    }

    public boolean getIsPerfectBox() {
        return isPerfectBox;
    }

    public float getBoxAngle() {
        return boxAngle;
    }

    public Coordinates getNW() {
        return NW;
    }

    public Coordinates getSW() {
        return SW;
    }

    public Coordinates getNE() {
        return NE;
    }

    public Coordinates getSE() {
        return SE;
    }

    public Coordinates[] getCorners() {
        Coordinates[] corners = {SW, NW, SE, NE};
        return corners;
    }

    public Coordinates getCenterPoint() {
        return centerPoint;
    }

    public float getHeight() {
        return height;
    }

    public float getWidth() {
        return width;
    }

    public float getGreatestXOfBox() {
        if (isPerfectBox) {
            return NE.getX();
        }

        if (NE.getX() > SE.getX()) {
            return NE.getX();
        } else if (SE.getX() > NE.getX()) {
            return SE.getX();
        } else {
            System.out.println("Inside findGreatestX, somethin wrong bruh");
            return 123123123.0f;
        }
    }

    public float getLeastXOfBox() {
        if (isPerfectBox) {
            return NW.getX();
        }

        if (NW.getX() < SW.getX()) {
            return NW.getX();
        } else if (SW.getX() < NW.getX()) {
            return SW.getX();
        } else {
            System.out.println("Inside findLeastX, something went bad");
            return 123231323423.0f;
        }
    }

    public float getGreatestYOfBox() {
        if (isPerfectBox) {
            return NW.getY();
        }

        if (NW.getY() > NE.getY()) {
            return NW.getY();
        } else if (NE.getY() > NW.getY()) {
            return NE.getY();
        } else {
            System.out.println("iside findGreatestY, somethin bad n stuff");
            return 123123123123.0f;
        }
    }

    public float getLeastYOfBox() {
        if (isPerfectBox) {
            return SW.getY();
        }

        if (SW.getY() < SE.getY()) {
            return SW.getY();
        } else if (SE.getY() < SW.getY()) {
            return SE.getY();
        } else {
            System.out.println("inside findLeastY, idk kek");
            return 123123123213.0f;
        }
    }

    public Box getPerfectBoxAroundBox() {
        return new Box(new Coordinates(this.getLeastXOfBox(), this.getGreatestYOfBox()), new Coordinates(this.getLeastXOfBox(), this.getLeastYOfBox()), new Coordinates(this.getGreatestXOfBox(), this.getGreatestYOfBox()), new Coordinates(this.getGreatestXOfBox(), this.getLeastYOfBox()));
    }
    
    public static float findGreatestFloatOf(float[] testArr){
        ArrayList<Float> testFloatList = new ArrayList<Float>();
        for(float testFloat : testArr){
            testFloatList.add(testFloat);
        }

        float currentTestFloat;
        float currentTestingListSize = testFloatList.size();
        outerLoop:
        for(int i = 0; i < currentTestingListSize; i++){
            currentTestFloat = testFloatList.get(i);
            testFloatList.remove(testFloatList.get(i));
            currentTestingListSize--;
            innerLoop:  
            for(float testingAgainst : testFloatList){
                if(testingAgainst > currentTestFloat){
                    i--;
                    continue outerLoop;
                }
            }
            return currentTestFloat;
        }
        //System.out.println("findgreatestfloat has gone wrong :(");
        return -1;
    }
    
    public static float findLeastFloatOf(float[] testArr){
        ArrayList<Float> testFloatList = new ArrayList<Float>();
        for(float testFloat : testArr){
            testFloatList.add(testFloat);
        }

        float currentTestFloat;
        float currentTestingListSize = testFloatList.size();
        outerLoop:
        for(int i = 0; i < currentTestingListSize; i++){
            currentTestFloat = testFloatList.get(i);
            testFloatList.remove(testFloatList.get(i));
            currentTestingListSize--;
            innerLoop:  
            for(float testingAgainst : testFloatList){
                if(testingAgainst < currentTestFloat){
                    i--;
                    continue outerLoop;
                }
            }
            return currentTestFloat;
        }
        //System.out.println("findgreatestfloat has gone wrong :(");
        return -1;
    }
    
    public Coordinates[] removePointsInPerfectBox(Coordinates[] testPoints) {
        ArrayList<Coordinates> pointsOutsideBoxList = new ArrayList<Coordinates>();
        float greatestX = this.getGreatestXOfBox();
        float greatestY = this.getGreatestYOfBox();
        float leastX = this.getLeastXOfBox();
        float leastY = this.getLeastYOfBox();
        for (Coordinates c : testPoints) {
            if (!(c.getX() <= greatestX
                    && c.getX() >= leastX
                    && c.getY() <= greatestY
                    && c.getY() >= leastY)) {
                System.out.println("asdfasdfadfs");
                pointsOutsideBoxList.add(c);
            } else {
                Box.printCoordinates(c);

            }
        }

        Coordinates[] pointsOutsideBoxArr = new Coordinates[pointsOutsideBoxList.size()];
        for (int i = 0; i < pointsOutsideBoxArr.length; i++) {
            pointsOutsideBoxArr[i] = pointsOutsideBoxList.get(i);
        }

        return pointsOutsideBoxArr;
    }

    public Coordinates[] removePointsOutsidePerfectBox(Coordinates[] testPoints) {
        ArrayList<Coordinates> pointsInBoxList = new ArrayList<Coordinates>();
        float greatestX = this.getGreatestXOfBox();
        float greatestY = this.getGreatestYOfBox();
        float leastX = this.getLeastXOfBox();
        float leastY = this.getLeastYOfBox();
        for (Coordinates c : testPoints) {
            if (c.getX() <= greatestX
                    && c.getX() >= leastX
                    && c.getY() <= greatestY
                    && c.getY() >= leastY) {
                pointsInBoxList.add(c);
            } else {
                //System.out.println("Outside point rmeoved");
            }
        }

        Coordinates[] pointsInBoxArr = new Coordinates[pointsInBoxList.size()];
        for (int i = 0; i < pointsInBoxArr.length; i++) {
            pointsInBoxArr[i] = pointsInBoxList.get(i);
        }

        return pointsInBoxArr;
    }

    public static Coordinates[] removePointsInPerfectBox(Coordinates[] testPoints, Coordinates cornerPointOne, Coordinates cornerPointTwo) {
        float greatestX;
        float greatestY;
        float leastX;
        float leastY;
        if (cornerPointOne.getX() > cornerPointTwo.getX()) {
            greatestX = cornerPointOne.getX();
            leastX = cornerPointTwo.getX();
        } else {
            greatestX = cornerPointTwo.getX();
            leastX = cornerPointOne.getX();
        }

        if (cornerPointOne.getY() > cornerPointTwo.getY()) {
            greatestY = cornerPointOne.getY();
            leastY = cornerPointTwo.getY();
        } else {
            greatestY = cornerPointTwo.getY();
            leastY = cornerPointOne.getY();
        }

        ArrayList<Coordinates> pointsNotInBoxList = new ArrayList<>();
        for (Coordinates c : testPoints) {
            if (!(c.getX() >= leastX
                    && c.getX() <= greatestX
                    && c.getY() >= leastY
                    && c.getY() <= greatestY)) {
                pointsNotInBoxList.add(c);
            } else {
                //System.out.println("Point removed.");
                //Box.printCoordinates(c);

            }
        }

        //Copy over list of points inside to be returned
        Coordinates[] pointsNotInBoxArr = new Coordinates[pointsNotInBoxList.size()];
        for (int i = 0; i < pointsNotInBoxList.size(); i++) {
            pointsNotInBoxArr[i] = pointsNotInBoxList.get(i);
        }

        return pointsNotInBoxArr;

    }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public static Coordinates[] removeAllPointsInRightTriangle(Coordinates startPoint, Coordinates ninetyDegreePoint, Coordinates endPoint, Coordinates[] testPoints) {
        int angleMultX = startPoint.getX() > endPoint.getX() ? -1 : 1;
        int angleMultY = startPoint.getY() > endPoint.getY() ? -1 : 1;

        int innerMultX = 0;
        int innerMultY = 0;
        if (Math.abs(startPoint.getX() - ninetyDegreePoint.getX()) < UNIVERSAL_EPSILON_VAL
                && Math.abs(endPoint.getY() - ninetyDegreePoint.getY()) < UNIVERSAL_EPSILON_VAL) {
            if (angleMultX == 1 && angleMultY == 1) {
                innerMultX = -1;
                innerMultY = 1;
            } else if (angleMultX == 1 && angleMultY == -1) {
                innerMultX = -1;
                innerMultY = -1;
            } else if (angleMultX == -1 && angleMultY == -1) {
                innerMultX = 1;
                innerMultY = -1;
            } else {
                innerMultX = -1;
                innerMultY = -1;
            }
        } else if (Math.abs(startPoint.getY() - ninetyDegreePoint.getY()) < UNIVERSAL_EPSILON_VAL
                && Math.abs(endPoint.getX() - ninetyDegreePoint.getX()) < UNIVERSAL_EPSILON_VAL) {
            if (angleMultX == 1 && angleMultY == 1) {
                innerMultX = 1;
                innerMultY = -1;
            } else if (angleMultX == 1 && angleMultY == -1) {
                innerMultX = 1;
                innerMultY = 1;
            } else if (angleMultX == -1 && angleMultY == -1) {
                innerMultX = -1;
                innerMultY = 1;
            } else {
                innerMultX = 1;
                innerMultY = 1;
            }
        } else {
            System.out.println("inside removeAllPointsInsideRightTriangle; multipliers not set, lines nto equal");
        }

        float xDist = Math.abs(startPoint.getX() - endPoint.getX());
        float yDist = Math.abs(startPoint.getY() - endPoint.getY());
        float currentMult = 1;

        int currentBoxNum;
        float currentXDist;
        float currentYDist;
        Coordinates currentHypotenusePoint = new Coordinates();
        Coordinates currentInnerPoint = new Coordinates();
        Coordinates[] currentRemovedPointsArr = testPoints;

        for (int i = 1; i < 5; i++) {
            currentMult /= 2;
            currentBoxNum = (int) (1.0f / (currentMult * 2));
            currentXDist = xDist * currentMult;
            currentYDist = yDist * currentMult;
            currentHypotenusePoint.setCoordinates(startPoint.getX() + currentXDist * angleMultX, startPoint.getY() + currentYDist * angleMultY);
            currentInnerPoint.setCoordinates(currentHypotenusePoint.getX() + currentXDist * innerMultX, currentHypotenusePoint.getY() + currentYDist * innerMultY);

            for (int j = 0; j < currentBoxNum; j++) {
                currentRemovedPointsArr = Box.removePointsInPerfectBox(currentRemovedPointsArr, currentHypotenusePoint, currentInnerPoint);
                //Box.printCoordinates(currentRemovedPointsArr);
                if (currentRemovedPointsArr.length == 0) {
                    return currentRemovedPointsArr;
                }
                currentHypotenusePoint.setCoordinates(currentHypotenusePoint.getX() + 2 * currentXDist * angleMultX, currentHypotenusePoint.getY() + 2 * currentYDist * angleMultY);
                currentInnerPoint.setCoordinates(currentHypotenusePoint.getX() + currentXDist * innerMultX, currentHypotenusePoint.getY() + currentYDist * innerMultY);

                //Box.printCoordinates(currentHypotenusePoint);
                //Box.printCoordinates(currentInnerPoint);
            }
        }

        return currentRemovedPointsArr;
    }

    public static Coordinates perfLineIntersectsPerfLineAt(Coordinates perfLineStartOne, Coordinates perfLineEndOne, Coordinates perfLineStartTwo, Coordinates perfLineEndTwo) {

        float regularDimLineOne;
        float regularDimLineTwo;
        float leastDimOfLineOne = 0;
        float greatestDimOfLineOne = 0;
        float leastDimOfLineTwo = 0;
        float greatestDimOfLineTwo = 0;

        boolean oneXWise = false;
        boolean twoXWise = false;

        //Find start line's dims
        if (Math.abs(perfLineStartOne.getX() - perfLineEndOne.getX()) < UNIVERSAL_EPSILON_VAL) {
            oneXWise = true;
            regularDimLineOne = perfLineStartOne.getX();
            //Find the least and greatest of the varying dimension of the line
            if (perfLineStartOne.getY() >= perfLineEndOne.getY()) {
                leastDimOfLineOne = perfLineEndOne.getY();
                greatestDimOfLineOne = perfLineStartOne.getY();
            } else if (perfLineStartOne.getY() <= perfLineEndOne.getY()) {
                leastDimOfLineOne = perfLineStartOne.getY();
                greatestDimOfLineOne = perfLineEndOne.getY();
            } else {
                //Equal
            }
        } else if (Math.abs(perfLineStartOne.getY() - perfLineEndOne.getY()) < UNIVERSAL_EPSILON_VAL) {
            oneXWise = false;
            regularDimLineOne = perfLineStartOne.getY();
            //Find the greatest and least of the varying dimensions of the line
            if (perfLineStartOne.getX() >= perfLineEndOne.getX()) {
                leastDimOfLineOne = perfLineEndOne.getX();
                greatestDimOfLineOne = perfLineStartOne.getX();
            } else if (perfLineStartOne.getX() <= perfLineEndOne.getX()) {
                leastDimOfLineOne = perfLineStartOne.getX();
                greatestDimOfLineOne = perfLineEndOne.getX();
            } else {
                //Equal?
            }
        } else {
            //Line one is not a perfect line, waddafuck
            //perfLineEndOne.printCoordinates();
            //perfLineStartOne.printCoordinates();
            //System.out.println("Line one is not perfect. Returning null.");
            return null;
        }

        //Find second line's dims
        if (Math.abs(perfLineStartTwo.getX() - perfLineEndTwo.getX()) < UNIVERSAL_EPSILON_VAL) {
            twoXWise = true;
            regularDimLineTwo = perfLineStartTwo.getX();
            //Find varying dimension least and greatest, etc.
            if (perfLineStartTwo.getY() >= perfLineEndTwo.getY()) {
                leastDimOfLineTwo = perfLineEndTwo.getY();
                greatestDimOfLineTwo = perfLineStartTwo.getY();
            } else if (perfLineStartTwo.getY() <= perfLineEndTwo.getY()) {
                leastDimOfLineTwo = perfLineStartTwo.getY();
                greatestDimOfLineTwo = perfLineEndTwo.getY();
            } else {
                //Equal?
            }
        } else if (Math.abs(perfLineStartTwo.getY() - perfLineEndTwo.getY()) < UNIVERSAL_EPSILON_VAL) {
            twoXWise = false;
            regularDimLineTwo = perfLineStartTwo.getY();
            if (perfLineStartTwo.getX() >= perfLineEndTwo.getX()) {
                leastDimOfLineTwo = perfLineEndTwo.getX();
                greatestDimOfLineTwo = perfLineStartTwo.getX();
            } else if (perfLineStartTwo.getX() <= perfLineEndTwo.getX()) {
                leastDimOfLineTwo = perfLineStartTwo.getX();
                greatestDimOfLineTwo = perfLineEndTwo.getX();
            } else {
                //Equal?
            }
        } else {
            //Line two is not perfect, waddafuck
            //System.out.println("Line two is not perfect. Returning null.");
            return null;
        }

        //System.out.println("oneXWise: " + oneXWise + ", twoXWise: " + twoXWise);
        
        //Start comparing and finding points
        if (!oneXWise && twoXWise) {
            if ((leastDimOfLineOne <= regularDimLineTwo && regularDimLineTwo <= greatestDimOfLineOne)
                    && (leastDimOfLineTwo <= regularDimLineOne && regularDimLineOne <= greatestDimOfLineTwo)) {
                return new Coordinates(perfLineStartTwo.getX(), perfLineStartOne.getY());
            } 
            else {
                return null;
            }
        } 
        else if (oneXWise && !twoXWise) {
            if ((leastDimOfLineOne <= regularDimLineTwo && regularDimLineTwo <= greatestDimOfLineOne)
                    && (leastDimOfLineTwo <= regularDimLineOne && regularDimLineOne <= greatestDimOfLineTwo)) {
                return new Coordinates(perfLineStartOne.getX(), perfLineStartTwo.getY());
            }
            else{
                return null;
            }
        }
        else if ((oneXWise && twoXWise)
                || (!oneXWise && !twoXWise)) {
            /*
             ALL OF THE BELOW CODE IS APPLIED ONLY WHEN ONEXWISE && TWOXWISE || !ONEXWISE && !TWOXWISE, KEEP CALM AND CARRY ON WITH OTHERS
             */
            //Check if regular dims are the same
            if (!(Math.abs(regularDimLineOne - regularDimLineTwo) < UNIVERSAL_EPSILON_VAL)) {
                //System.out.println("RegularDims are not the same");
                return null;
            }
            //Check if either are within the other's bounds
           // System.out.println("leastDimlineOne: " + leastDimOfLineOne + ", greatestDimLineOne: "+ greatestDimOfLineOne);
           // System.out.println("leastDimLineTw: " + leastDimOfLineTwo + ", greatestDimineTwo: " + greatestDimOfLineTwo);
            //System.out.println("reguarllineone: " + regularDimLineOne + ", regualrtwo "+ regularDimLineTwo);
            
            //REDOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
            if (!((leastDimOfLineOne <= leastDimOfLineTwo && leastDimOfLineTwo <= greatestDimOfLineOne)
                    || (leastDimOfLineOne <= greatestDimOfLineTwo && greatestDimOfLineTwo <= greatestDimOfLineOne)
                    || (leastDimOfLineTwo <= leastDimOfLineOne && leastDimOfLineOne <= greatestDimOfLineTwo)
                    || (leastDimOfLineTwo <= greatestDimOfLineOne && greatestDimOfLineOne <= greatestDimOfLineTwo))) {
                return null;
            }

            //Only 2 possibilites here
            //Check if line one's points are both inside lineTwo
            if ((leastDimOfLineTwo <= leastDimOfLineOne && greatestDimOfLineOne <= greatestDimOfLineTwo)
                    && (leastDimOfLineTwo <= greatestDimOfLineOne && greatestDimOfLineOne <= greatestDimOfLineTwo)) {
                float distOne = Box.getDistanceBetween(perfLineStartOne, perfLineStartTwo);
                float distTwo = Box.getDistanceBetween(perfLineEndOne, perfLineStartTwo);

                //Find the point of perfLineOne that is closest to perfLineStartOne
                //If the start point is farther away from perfLineTwo's start
                if (distOne > distTwo) {
                    return perfLineEndOne;
                } //If the end point is farther away from perfLineTwo's start
                else if (distTwo > distOne) {
                    return perfLineStartOne;
                } //If the distance is equal, then perfLine's points are right on top of each other
                else {
                    return perfLineStartOne;
                }
            } //At least one point, if not two, are inside lineOne
            else {
                //Find which points of lineTwo are within line One's bounds
                Coordinates[] lineTwoPoints = {perfLineStartTwo, perfLineEndTwo};
                ArrayList<Coordinates> pointsBetweenLineOne = new ArrayList<Coordinates>(2);
                int pointsCount = 0;
                for (int i = 0; i < 2; i++) {
                    if (twoXWise) {
                        if (leastDimOfLineOne <= lineTwoPoints[i].getY() && lineTwoPoints[i].getY() <= greatestDimOfLineOne) {
                            pointsBetweenLineOne.add(lineTwoPoints[i]);
                            pointsCount++;
                        } 
                    }
                        else if (!twoXWise) {
                            if (leastDimOfLineOne <= lineTwoPoints[i].getX() && lineTwoPoints[i].getX() <= greatestDimOfLineOne) {
                                pointsBetweenLineOne.add(lineTwoPoints[i]);
                                pointsCount++;
                            }
                        } 
                        else {
                            return null;
                        }
                 }
                   
                    if (pointsBetweenLineOne.size() == 1) {
                        return pointsBetweenLineOne.get(0);
                    } //Both points of lineTwo are between lineOne
                    else if (pointsBetweenLineOne.size() == 2) {
                        float distOne = Box.getDistanceBetween(perfLineStartTwo, perfLineStartOne);
                        float distTwo = Box.getDistanceBetween(perfLineEndTwo, perfLineStartOne);

                        //Find the point of perfLineTwo that is closest to perfLineStartOne
                        //If startPoit of line two is farther away than endPoint
                        if (distOne > distTwo) {
                            return perfLineEndTwo;
                        } //If the end point is farther away from perfLineOne's start
                        //If end point of lineTwo is farthere away than start point
                        else if (distTwo > distOne) {
                            return perfLineStartTwo;
                        } //If the distance is equal, then perfLine's points are right on top of each other
                        else {
                            return perfLineStartTwo;
                        }
                    } 
                    else {
                        return null;
                    }
                }
            }
        //System.out.println("Shouldn't happen: perfLineIntersectsPerfLineAt: returning null");
        return null;
    }

    public boolean anyPointsAreInBox(Coordinates[] testPoints) {
        //Box is perfect and angle is therefore 0, 180, etc.
        if (isPerfectBox) {
            if (this.anyPointsAreInPerfectBox(testPoints)) {
                return true;
            } else {
                return false;
            }
        }

        float adjustedAngle;
        if (boxAngle > 180) {
            adjustedAngle = boxAngle - 180;
        } else {
            adjustedAngle = boxAngle;
        }

        Box perfectBox = this.getPerfectBoxAroundBox();
        Coordinates[] currentUnremovedPoints = perfectBox.removePointsOutsidePerfectBox(testPoints);

        Coordinates correspondingPointSWNW;
        Coordinates correspondingPointSWSE;
        Coordinates correspondingPointNWNE;
        Coordinates correspondingPointSENE;
        if (adjustedAngle < 90) {
            correspondingPointSWNW = perfectBox.getSW();
            correspondingPointSWSE = perfectBox.getSE();
            correspondingPointNWNE = perfectBox.getNW();
            correspondingPointSENE = perfectBox.getNE();
        } else {
            correspondingPointSWNW = perfectBox.getNW();
            correspondingPointSWSE = perfectBox.getSW();
            correspondingPointNWNE = perfectBox.getNE();
            correspondingPointSENE = perfectBox.getSE();
        }

        Coordinates[] cornerPairsArrOne = {SW, SE, NW, SW};
        Coordinates[] correspondingPointsArr = {correspondingPointSWNW, correspondingPointSENE, correspondingPointNWNE, correspondingPointSWSE};
        Coordinates[] cornerPairsArrTwo = {NW, NE, NE, SE};

        for (int i = 0; i < 4; i++) {
            currentUnremovedPoints = Box.removeAllPointsInRightTriangle(cornerPairsArrOne[i], correspondingPointsArr[i], cornerPairsArrTwo[i], currentUnremovedPoints);
            if (currentUnremovedPoints.length == 0) {
                return false;
            }
        }

        return true;
    }

    public static Coordinates linesIntersectAtPoint(Coordinates startPoint, Coordinates endPoint, Coordinates startPointTwo, Coordinates endPointTwo){
	float intersectionX = 
	 ((startPoint.getX()*endPoint.getY()-endPoint.getX()*startPoint.getY())*(startPointTwo.getX()-endPointTwo.getX()) - ((startPoint.getX()-endPoint.getX())*(startPointTwo.getX()*endPointTwo.getY()-startPointTwo.getY()*endPointTwo.getX()))) /
	 ((startPoint.getX()-endPoint.getX())*(startPointTwo.getY()-endPointTwo.getY()) - (startPoint.getY()-endPoint.getY())*(startPointTwo.getX()-endPointTwo.getX()));
	
	float intersectionY = 
	 ((startPoint.getX()*endPoint.getY()-endPoint.getX()*startPoint.getY())*(startPointTwo.getY()-endPointTwo.getY()) - ((startPoint.getY()-endPoint.getY())*(startPointTwo.getX()*endPointTwo.getY()-startPointTwo.getY()*endPointTwo.getX()))) /
	 ((startPoint.getX()-endPoint.getX())*(startPointTwo.getY()-endPointTwo.getY()) - (startPoint.getY()-endPoint.getY())*(startPointTwo.getX()-endPointTwo.getX()));
	
        //I know this isn't as effiecient as if/then strings, but fuck you I'm not writing another 12-odd blocks of statements
        float leastXOfLineOne = startPoint.getX() >= endPoint.getX() ? endPoint.getX() : startPoint.getX();
        float greatestXOfLineOne = startPoint.getX() >= endPoint.getX() ? startPoint.getX() : endPoint.getX();
        float leastYOfLineOne = startPoint.getY() >= endPoint.getY() ? endPoint.getY() : startPoint.getY();
        float greatestYOfLineOne = startPoint.getY() >= endPoint.getY() ? startPoint.getY() : endPoint.getY();
        
        float leastXOfLineTwo = startPointTwo.getX() >= endPointTwo.getX() ? endPointTwo.getX() : startPointTwo.getX() ;
        float greatestXOfLineTwo = startPointTwo.getX() >= endPointTwo.getX() ? startPointTwo.getX() : endPointTwo.getX();
        float leastYOfLineTwo = startPointTwo.getY() >= endPointTwo.getY() ? endPointTwo.getY() : startPointTwo.getY();
        float greatestYOfLineTwo = startPointTwo.getY() >= endPointTwo.getY() ? startPointTwo.getY() : endPointTwo.getY();
        
        
        if(
            !(
              ((leastXOfLineOne <= intersectionX && intersectionX <= greatestXOfLineOne) && (leastYOfLineOne <= intersectionY && intersectionY <= greatestYOfLineOne)) &&
              ((leastXOfLineTwo <= intersectionX && intersectionX <= greatestXOfLineTwo) && (leastYOfLineTwo <= intersectionY && intersectionY <= greatestYOfLineTwo))
            )
        ){
            Coordinates c = Box.perfLineIntersectsPerfLineAt(startPoint, endPoint, startPointTwo, endPointTwo);
            if(c != null){
                return c;
            }
            //System.out.println("null");
            return null;
        }
        
	return new Coordinates(intersectionX, intersectionY);
    }
    
    public boolean doesBoxCollideWithBox(Box comparingBox){
        if(this.anyPointsAreInBox(comparingBox.getCorners()) || comparingBox.anyPointsAreInBox(this.getCorners())){
            return true;
        }

        Coordinates[] lineSegmentsOfCornersOfThis = {this.getSW(), this.getSE(), this.getNW(), this.getSW(), this.getSE(), this.getNE(), this.getNW(), this.getNE()};
        Coordinates[] lineSegmentsOfCornersOfComparing = {comparingBox.getSW(), comparingBox.getSE(), comparingBox.getNW(), comparingBox.getSW(), comparingBox.getSE(), comparingBox.getNE(), comparingBox.getNW(), comparingBox.getNE()};

        for(int i = 0; i < 7; i += 2){
            for(int j = 0; j < 7; j +=2){
                if(Box.linesIntersectAtPoint(lineSegmentsOfCornersOfThis[i], lineSegmentsOfCornersOfThis[i+1], lineSegmentsOfCornersOfComparing[j], lineSegmentsOfCornersOfComparing[j+1]) != null){
                    lineSegmentsOfCornersOfThis[i].printCoordinatesForTesting();
                    lineSegmentsOfCornersOfThis[i+1].printCoordinatesForTesting();
                    lineSegmentsOfCornersOfComparing[j].printCoordinatesForTesting();
                    lineSegmentsOfCornersOfComparing[j+1].printCoordinatesForTesting();
                    
                    return true;
                }
            }   
        }   
        
        return false;
    }

}
